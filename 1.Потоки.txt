Типы данных:
pthread_t: дескриптор потока;
pthread_attr_t: перечень атрибутов потока;
pthread_barrier_t: барьер;
pthread_barrierattr_t: атрибуты барьера;
pthread_cond_t: условная переменная;
pthread_condattr_t: атрибуты условной переменной;
pthread_key_t: данные, специфичные для потока;
pthread_mutex_t: мьютекс;
pthread_mutexattr_t: атрибуты мьютекса;
pthread_rwlock_t: мьютекс с возможностью эксклюзивной блокировки;
pthread_rwlockattr_t: атрибуты этого мьютекса;
pthread_spinlock_t: спинлок;

Функции управления потоками:
pthread_create(): создание потока.
pthread_exit(): завершение потока (должна вызываться функцией потока при завершении).
pthread_cancel(): запрос на отмену потока.
pthread_join(): подключиться к другому потоку и ожидать его завершения; 
	поток, к которому необходимо подключиться, должен быть создан с возможностью подключения (PTHREAD_CREATE_JOINABLE).
pthread_detach(): отключиться от потока, сделав его при этом отдельным (PTHREAD_CREATE_DETACHED).
pthread_attr_init(): инициализировать структуру атрибутов потока.
pthread_attr_setdetachstate(): указывает параметр "отделимости" потока (detach state), 
	который говорит о возможности подключения к нему (при помощи pthread_join) других потоков (значение PTHREAD_CREATE_JOINABLE)
	для ожидания окончания или о запрете подключения (значение PTHREAD_CREATE_DETACHED);
	ресурсы отдельного потока (PTHREAD_CREATE_DETACHED) при завершении автоматически освобождаются и возвращаются системе.
pthread_attr_destroy(): освободить память от структуры атрибутов потока (уничтожить дескриптор).

Функции синхронизации потоков:
pthread_mutex_init(), pthread_mutex_destroy(), pthread_mutex_lock(), pthread_mutex_trylock(), pthread_mutex_unlock(): с помощью мьютексов.
pthread_cond_init(), pthread_cond_signal(), pthread_cond_wait(): с помощью условных переменных.

pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancelation clean-up handlers
pthread_setcancelstate, pthread_setcanceltype - set cancelability state (PTHREAD_CANCEL_ENABLE/DISABLE)
							       and type (PTHREAD_CANCEL_DEFERRED/ASYNCHRONOUS) (отложенный/асинхронный)

sigwait - ожидание сигнала
	Функция  sigwait()  приостанавливает выполнение вызвавшей нити до тех пор, пока в ожидании
	не появится сигнал из заданного набора сигналов set. Функция принимает сигнал (удаляет его
	из списка ожидающих сигналов) и возвращает номер сигнала в sig.
------------------------------------------------------------------------------------------------------------------------------------------
Поток выполнения (thread — нить) — наименьшая единица планирования, исполнение которой может быть назначено планировщиком процессов.
	*Отличие от процессов*
процессы, как правило, независимы, тогда как потоки выполнения существуют как составные элементы процессов.
процессы несут значительно больше информации о состоянии, тогда как несколько потоков выполнения внутри процесса
	совместно используют информацию о состоянии, а также память и другие вычислительные ресурсы.
процессы имеют отдельные адресные пространства, тогда как потоки выполнения совместно используют их адресное пространство.
процессы взаимодействуют только через предоставляемые системой механизмы связей между процессами.
переключение контекста между потоками выполнения в одном процессе, как правило, быстрее, чем переключение контекста между процессами.


Процесс с точки зрения ОС - некая управляющая структура, позволяющая исполнять программы,
диспетчеризировать их в процессе их жизни, планировать их на исполнение, снимать их с исполнения,
реагировать на нештатные ситуации, посылать сигналы и т.п.

-----------------------------------------------------------------------
Процесс — это абстракция, реализованная на уровне операционной системы.
	Процесс был придуман для организации всех данных, необходимых для работы программы.
Процесс можно представить как контейнер, в котором находятся ресурсы программы:
	* адресное пространство
	* потоки
	* открытые файлы
	* дочерние процессы
	и т.д.
Поток — это абстракция, реализованная на уровне операционной системы. Поток был придуман для контроля выполнения кода программы.
У потока есть:
	*Счётчик команд
	*Регистры
	*Стек
Поток "легче", чем процесс, и создание потока стоит дешевле. Потоки используют адресное пространство процесса, которому они принадлежат,
		поэтому потоки внутри одного процесса могут обмениваться данными и взаимодействовать с другими потоками.
-----------------------------------------------------------------------------------
--------Почему нужна поддержка множества потоков внутри одного процесса?-----------

В случае, когда одна программа выполняет множество задач, поддержка множества потоков внутри одного процесса позволяет:
	*Разделить ответственность за разные задачи между разными потоками
	*Повысить быстродействие

Кроме того, часто задачам необходимо обмениваться данными, использовать общие данные или результаты других задач.
Такую возможность предоставляют потоки внутри процесса, так как они используют адресное пространство процесса, которому принадлежат.
Конечно, можно было бы создать под разные задачи дополнительные процессы, но:
	* У процесса будет отдельное адресное пространство и данные, что затруднит взаимодействие частей программы
	* Создание и уничтожение процесса дороже, чем создание и уничтожение потока


	clone flags:
CLONE_SIGHAND (начиная с Linux 2.0) - flag
Если задан флаг CLONE_SIGHAND, то вызывающий процесс и процесс-потомок используют одну и ту же таблицу обработчиков сигналов.
Если вызывающий процесс или процесс-потомок вызывают sigaction(2) для изменения поведения при получении сигнала, то это поведение изменяется также и в другом процессе.
Однако, вызывающий процесс и процесс-потомок имеют различные маски сигналов и списки ожидающих обработки сигналов.
Так, один из них может блокировать или деблокировать некоторые сигналы, используя sigprocmask(2), и это не будет влиять на другой процесс.
Если флаг CLONE_SIGHAND не указан, то процесс-потомок наследует копию обработчиков событий вызывающего процесса, снятую на момент вызова clone().
Вызовы sigaction(2), выполняемые позже одним из процессов, не оказывают влияния на другой процесс.
Начиная с Linux 2.6.0-test6, flags должен также включать CLONE_VM, если указан CLONE_SIGHAND.
